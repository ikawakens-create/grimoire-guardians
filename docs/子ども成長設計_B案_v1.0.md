---
title: "子ども成長設計 B案"
version: "1.0"
date: "2026-02-20"
status: "Geminiレビュー依頼中"
author: "Claude"
reviewers: ["Gemini（レビュー依頼中）"]
project: "Grimoire Guardians"
phase: "Phase 1 設計段階"
document_type: "設計提案書（レビュー用）"
related_docs:
  - "ロードマップ v1.4"
  - "統合仕様書 v1.3"
  - "UI設計書 v1.1"
purpose: "子どもの成長を可視化するシステム設計の代替案（B案）をGeminiにレビュー依頼"
---

# 🌳 子ども成長設計 B案 v1.0
## Grimoire Guardians — 「まなびの き」成長システム設計提案

---

## 📋 このドキュメントの目的

### Geminiへのレビュー依頼

本ドキュメントは、**子どもプレイヤーの成長を可視化するシステム**の代替設計案（B案）です。

現在の設計（A案: 家ビルドシステム）に対し、**「まなびの き（学びの木）」**という別のメタファーを提案します。

**Geminiに確認したい点:**
1. 小学1〜6年生に「木が育つ」メタファーは伝わるか？
2. A案（家ビルド）とB案（木の成長）、どちらが教育効果・継続率が高いか？
3. 実装コスト・UX観点での懸念事項はあるか？
4. 改善・折衷案があれば提案を歓迎する

---

## 📚 目次

1. [設計背景とA案の概要](#1-設計背景とa案の概要)
2. [B案コンセプト「まなびの き」](#2-b案コンセプトまなびの-き)
3. [詳細設計](#3-詳細設計)
4. [A案との比較](#4-a案との比較)
5. [実装方針](#5-実装方針)
6. [懸念事項と未解決問題](#6-懸念事項と未解決問題)
7. [Geminiへの質問事項](#7-geminiへの質問事項)

---

## 1. 設計背景とA案の概要

### 1-1. 解決したい課題

現在の設計では、子どもが以下を感じにくいという懸念がある:

```
❓ 課題1: 「じぶんが つよくなった」実感が薄い
   → 素材を集めているが、キャラクター自身の成長が見えない

❓ 課題2: 「どれくらい おぼえたか」が分からない
   → スター数・クリア率はあるが、「学習の深さ」が可視化されていない

❓ 課題3: 長期的な継続動機
   → 家ビルドは素材がたまれば完成→終わり？になりがち
   → 木は「育て続ける」ことに意味がある

❓ 課題4: 個性・愛着
   → 全プレイヤーの家が同じ形になる可能性
   → 木は育て方・飾り方で個性が出やすい
```

### 1-2. A案（家ビルドシステム）の概要

```yaml
A案: 家ビルドシステム
  コンセプト: 素材を集めて家を建てる

  フロー:
    1. 問題を解く → 素材ドロップ
    2. 素材をインベントリに収集
    3. 家ビルド画面で素材を使って家を建築
    4. スキンで見た目をカスタマイズ

  素材:
    - もくざい（木材）
    - いし（石）
    - レンガ
    - きらきらいし（宝石）
    - ほしのかけら

  強み:
    - 「何かを作る」達成感
    - 素材集めがゲームの中心的動機
    - 統合仕様書v1.3に詳細仕様あり

  Phase実装:
    - Phase 0: 素材を集めるだけ（見るだけ）
    - Phase 1: 家ビルド機能実装
    - Phase 2: スキン機能実装
```

---

## 2. B案コンセプト「まなびの き」

### 2-1. 基本コンセプト

```
🌳 「まなびの き」= プレイヤー固有の魔法の木

・問題を解くたびに木が育つ
・単元をクリアするたびに枝が伸び、花や実がなる
・木の形・色・飾りは学習内容を反映する
・「じぶんだけの き」として愛着が生まれる
```

**デザイン哲学:**

```
子どもにとって「成長」とは、
数字（レベル・スター数）より
「目に見えて変わる何か」への共感が深い。

木が少しずつ育つ = じぶんが少しずつ賢くなる

という直感的なメタファーを採用する。
```

### 2-2. ビジュアルイメージ

```
【Phase 0開始時】             【Phase 0.3完了時】
    🌱                         🌳
    （小さな芽）                 （大きな木）
                              🍎🍊🌸🌟
                            /    |    \
                          🌿    🌿    🌿
                            \   |   /
                             [幹]
                              |
                         [根っこが大地に]

左側: 本棚画面の隅（小さく常時表示）
右側: 「きのへや」画面（全画面表示・タップで訪問）
```

### 2-3. 成長のトリガー

```yaml
木の成長イベント:

  芽が出る（ゲーム開始時）:
    - チュートリアル完了
    - 「まほうの き が めをだした！」
    - 演出: 種が光って芽が出る

  幹が太くなる（単元クリアごと）:
    - M1-01〜M1-06 → 幹が6段階成長
    - 達成した単元数 = 幹の太さ
    - 演出: ゆっくり太くなるアニメ

  枝が伸びる（単元クリアごと）:
    - 1単元クリア = 1本の枝
    - 枝の方向 = ランダム（木ごとに形が違う）
    - 演出: 枝がのびる → 葉っぱがつく

  花が咲く（スコア80%以上でクリア）:
    - 花の種類 = 単元の内容で変わる
      M1-01: 白い花（かず → シンプル）
      M1-04: ピンクの花（たし算 → 温かい）
      M1-10: 金色の花（繰り上がり → 難しい単元なので特別）
    - 演出: 花びらがふわっと開く

  実がなる（90%以上でクリア）:
    - 実の種類 = 素材と連動
      🍎 りんご = もくざい
      🍊 みかん = いし
      ✨ きらきらのみ = きらきらいし
    - 演出: 実がぷっくりとふくらむ

  星がかがやく（100%・パーフェクト）:
    - 枝の先に星が光る
    - 演出: キラキラと輝き続ける
```

---

## 3. 詳細設計

### 3-1. 「きのへや」画面

```yaml
画面構成:
  メインエリア:
    - 木の全体表示（中央）
    - ゆっくり揺れるアニメーション（風で揺れる）
    - タップした枝/花/実 → その単元の思い出を表示

  情報パネル（下部）:
    - 木のニックネーム（プレイヤーが名前をつけられる）
    - 「○○の まなびの き」
    - 育てた日数
    - 咲いた花の数・なった実の数

  飾りシステム:
    - 素材を使って木を飾れる
    - 例: きらきらいし → 木にキラキラ飾りをつける
    - 例: ぬの → リボンを巻く
    - 例: まほうのたま → 木全体が光る

アクセス方法:
  - 本棚画面の「🌳 きのへや」ボタン
  - 本棚右下に木のサムネイルを常時表示（小）
    → タップで「きのへや」へ遷移
```

### 3-2. 木の成長アルゴリズム

```javascript
// 木の状態管理（GameStore連携）
const TREE_STATE_SCHEMA = {
  // 幹の成長段階 (0〜16)
  trunkLevel: 0,

  // 枝データ（単元ごと）
  branches: {
    // キー: 単元ID (例: 'M1-01')
    'M1-01': {
      unlocked: false,      // 枝が存在するか
      flowers: [],          // 咲いた花の種類
      fruits: [],           // なった実の種類
      stars: false,         // 星が光るか
      score: 0,             // 最高スコア(%)
      clearedAt: null,      // クリア日時
    }
  },

  // 飾り（素材で購入）
  decorations: [],

  // ニックネーム
  nickname: '',

  // 特殊状態
  isGlowing: false,         // まほうのたまで光っているか
  season: 'spring',         // 季節（見た目変化）
};

// 成長処理
class LearningTree {

  /**
   * 単元クリア時に木を成長させる
   * @param {string} unitId - 単元ID
   * @param {number} score - スコア（0〜100）
   */
  static growOnUnitClear(unitId, score) {
    const state = GameStore.getState('tree');

    // 枝を解放
    const branch = {
      unlocked: true,
      score,
      clearedAt: new Date().toISOString(),
      flowers: [],
      fruits: [],
      stars: false,
    };

    // 花が咲く（80%以上）
    if (score >= 80) {
      branch.flowers.push(this.getFlowerType(unitId));
    }

    // 実がなる（90%以上）
    if (score >= 90) {
      branch.fruits.push(this.getFruitType(unitId));
    }

    // 星が光る（100%）
    if (score === 100) {
      branch.stars = true;
    }

    // 幹を成長させる
    const newTrunkLevel = state.trunkLevel + 1;

    GameStore.mergeState('tree', {
      trunkLevel: newTrunkLevel,
      branches: {
        ...state.branches,
        [unitId]: branch,
      }
    });

    // 成長アニメーション再生
    return this.playGrowthAnimation(unitId, score);
  }

  /**
   * 単元に対応した花の種類を返す
   * @param {string} unitId
   * @returns {string} 花の種類ID
   */
  static getFlowerType(unitId) {
    const FLOWER_MAP = {
      'M1-01': 'white',       // なかまづくり → 白い花
      'M1-02': 'yellow',      // 10までのかず → 黄色
      'M1-03': 'blue',        // なんばんめ → 青（順序＝青空）
      'M1-04': 'pink',        // いくつといくつ → ピンク
      'M1-05': 'orange',      // あわせていくつ → オレンジ（温かい）
      'M1-06': 'purple',      // のこりはいくつ → 紫
      'M1-07': 'light-blue',  // 10より大きいかず
      'M1-08': 'silver',      // なんじ（時計） → 銀
      'M1-09': 'coral',       // 3つのかず
      'M1-10': 'gold',        // たしざん（繰り上がり）★★ → 金
      'M1-11': 'teal',        // かたちあそび → 青緑
      'M1-12': 'rose',        // ひきざん（繰り下がり）★★ → バラ
      'M1-13': 'mint',        // どちらがひろい
      'M1-14': 'deep-blue',   // おおきいかず → 深い青
      'M1-15': 'lavender',    // なんじなんぷん → ラベンダー
      'M1-16': 'rainbow',     // ずをつかって → レインボー（最終）
    };
    return FLOWER_MAP[unitId] ?? 'white';
  }

  /**
   * 単元に対応した実の種類を返す
   * @param {string} unitId
   * @returns {string} 実の種類（素材ID）
   */
  static getFruitType(unitId) {
    // 実は素材と同じIDで管理（インベントリとの連携）
    const FRUIT_MAP = {
      'M1-01': 'wood',
      'M1-02': 'wood',
      'M1-03': 'stone',
      'M1-04': 'stone',
      'M1-05': 'brick',
      'M1-06': 'brick',
      'M1-07': 'gem',
      'M1-08': 'cloth',
      'M1-09': 'gem',
      'M1-10': 'star_fragment',   // 繰り上がり = レア
      'M1-11': 'paint',
      'M1-12': 'star_fragment',   // 繰り下がり = レア
      'M1-13': 'gem',
      'M1-14': 'magic_orb',
      'M1-15': 'crown',
      'M1-16': 'magic_orb',       // 最終単元 = 超レア
    };
    return FRUIT_MAP[unitId] ?? 'wood';
  }

  /**
   * 成長アニメーション再生
   * @param {string} unitId
   * @param {number} score
   */
  static async playGrowthAnimation(unitId, score) {
    // 1. 幹が太くなる
    await TreeRenderer.animateTrunkGrowth();

    // 2. 枝が伸びる
    await TreeRenderer.animateBranchGrow(unitId);

    // 3. 葉っぱがつく
    await TreeRenderer.animateLeavesAppear(unitId);

    // 4. 花が咲く（80%以上）
    if (score >= 80) {
      await TreeRenderer.animateFlowerBloom(unitId);
    }

    // 5. 実がなる（90%以上）
    if (score >= 90) {
      await TreeRenderer.animateFruitGrow(unitId);
    }

    // 6. 星が光る（100%）
    if (score === 100) {
      await TreeRenderer.animateStarShine(unitId);
    }

    Logger.info(`🌳 まなびの き が そだった！ 単元: ${unitId} スコア: ${score}%`);
  }
}
```

### 3-3. 木のビジュアル実装方針

```yaml
実装技術:
  アプローチ: SVG + CSS Animations
  理由:
    - 純粋なVanilla JS（フレームワーク不使用）に合致
    - 枝・葉・花をSVGパスで表現
    - CSSアニメーションでGPU加速
    - レスポンシブ対応が容易

SVG構成:
  木全体: <svg id="learning-tree" viewBox="0 0 400 600">

  レイヤー構成（下から）:
    1. <g id="roots">    根っこ（背景）
    2. <g id="trunk">    幹（成長する）
    3. <g id="branches"> 枝群（単元ごとに追加）
    4. <g id="leaves">   葉っぱ（自動生成）
    5. <g id="flowers">  花（スコア80%+で出現）
    6. <g id="fruits">   実（スコア90%+で出現）
    7. <g id="stars">    星（パーフェクトで出現）
    8. <g id="deco">     飾り（素材で解放）

アニメーション:
  @keyframes branch-grow:
    transform: scaleY(0→1)（根元から先端へ伸びる）

  @keyframes flower-bloom:
    transform: scale(0→1) + opacity(0→1)
    easing: cubic-bezier(0.34, 1.56, 0.64, 1)（弾む感じ）

  @keyframes leaf-appear:
    transform: scale(0→1) rotate(-20deg→0deg)

  @keyframes star-shine:
    filter: brightness(1→2→1)
    animation-iteration-count: infinite

  @keyframes tree-sway:
    transform: rotate(-2deg→2deg)
    animation-duration: 4s
    animation-iteration-count: infinite
    animation-timing-function: ease-in-out

パフォーマンス:
  - will-change: transform を木全体に適用
  - GPU加速で60fps維持
  - SVGはrequestAnimationFrameでアップデート
```

### 3-4. 「きのへや」との素材連携

```yaml
A案（家ビルド）との連携:

  素材の二重活用:
    - 素材はインベントリで共有
    - A案: 素材 → 家の建材
    - B案: 素材 → 木の飾り

    → どちらに使うか プレイヤーが選択できる
    → 「家も建てたいし、木も飾りたい！」という欲望が生まれる

飾りの例:
  きらきらいし（gem）× 3:
    → 「キラキラかざり」
    → 木の枝に光るクリスタルが吊り下がる

  ぬの（cloth）× 5:
    → 「リボン」
    → 幹にリボンが巻かれる

  まほうのたま（magic_orb）× 1:
    → 「まほうの かがやき」
    → 木全体が魔法の光を放つ（常時光る）

  ほしのかけら（star_fragment）× 3:
    → 「ながれぼし」
    → 木の周りに流れ星が飛ぶエフェクト

  おうかん（crown）× 1:
    → 「きのおうかん」
    → 木のてっぺんに王冠がのる

季節変化（自動）:
  春: 桜の花びらが舞う（背景エフェクト）
  夏: 葉っぱが濃い緑、セミ（🦗）アイコン登場
  秋: 葉っぱが紅葉（赤・黄）
  冬: 雪が積もる（白いエフェクト）

  ※現実のカレンダー（Date）を参照
  ※日本の四季に対応
```

---

## 4. A案との比較

### 4-1. 比較マトリックス

```yaml
比較軸              A案（家ビルド）          B案（まなびの き）
-------------------------------------------------------------------
コンセプト           物を作る・集める          育てる・成長する
主なメタファー        建築・コレクション        植物・生命
対象年齢              全年齢                   全年齢（特に低学年）
学習との連動         間接的（素材が出る）      直接的（単元 = 枝）
成長の可視化         家の完成度               木の形・大きさ
個性・愛着           家の外観                 木の形・飾り
継続動機             「完成させたい」          「もっと育てたい」
リプレイ動機         スキン収集                飾り収集・パーフェクト
終わりの感覚         家が完成 → 満足          木は無限に育つ → 継続
実装コスト           中（3D的な家UIが必要）   中（SVGアニメ）
サーバー依存         なし（PWA）              なし（PWA）
保護者への見せやすさ 低（ゲーム感が強い）      高（「これが学びの記録」）
子どもへの説明       「いえを たてよう！」      「きを そだてよう！」
```

### 4-2. 教育観点の比較

```yaml
A案（家ビルド）の教育観:
  ✅ 素材収集 → 創造（建築）→ 達成感
  ✅ 計画的な素材管理
  ⚠️ 「学習 = 素材を得る手段」になりがち
  ⚠️ 家が完成したら学習動機が下がる可能性

B案（まなびの き）の教育観:
  ✅ 問題を解く = 木が育つ（直接的な因果）
  ✅ 「学習記録」として保護者に見せやすい
  ✅ 木は無限に育つ（完成がない）
  ✅ パーフェクトへの挑戦動機
  ⚠️ 「木を育てたい」が主動機になると本末転倒
  ⚠️ 「かわいい家」ほどの視覚的インパクトがあるか？

折衷案（参考）:
  家ビルドの家の庭に「まなびの き」を植える
  → 家ビルド（A案）をメインに据えつつ
  → 庭の木がサブ的に成長する
  → 両方の良さを取れる
  → ただし実装コストが増大する
```

---

## 5. 実装方針

### 5-1. Phase対応

```yaml
Phase 0（現在）:
  実装内容:
    - GameStoreにtree状態追加（_getInitialState更新）
    - 単元クリア時にtree状態を更新する処理
    - ※視覚的な木のUIは実装しない（データのみ）
  工数: 0.5日

Phase 1:
  実装内容:
    - 「きのへや」画面（TreeScreen）新規作成
    - SVGベースの木レンダリング
    - 成長アニメーション（CSSキーフレーム）
    - 本棚画面にサムネイル表示
  工数: 3〜4日

Phase 1.5（オプション）:
  実装内容:
    - 飾りシステム（素材との連携）
    - 季節変化
    - ニックネーム入力
    - タップで単元の「思い出」表示
  工数: 2〜3日
```

### 5-2. GameStore 状態変更

```javascript
// src/core/GameStore.js の _getInitialState() に追加

_getInitialState() {
  return {
    // ... 既存の状態

    // B案追加: まなびの き
    tree: {
      trunkLevel: 0,
      branches: {},           // 単元IDをキーにしたオブジェクト
      decorations: [],        // 装備中の飾りリスト
      nickname: '',           // 木のニックネーム
      isGlowing: false,       // まほうのたまで光っているか
      createdAt: null,        // 木が芽吹いた日時
      lastGrownAt: null,      // 最後に成長した日時
    },
  };
}
```

### 5-3. ファイル構成（追加予定）

```
src/
├── screens/
│   └── TreeScreen.js       # 「きのへや」画面（Phase 1）
├── components/
│   ├── TreeRenderer.js     # SVG木レンダリング（Phase 1）
│   └── TreeSummary.js      # 本棚画面のサムネイル（Phase 1）
└── effects/
    └── TreeEffects.js      # 成長アニメーション（Phase 1）

styles/
└── tree.css                # 木専用スタイル（Phase 1）
```

---

## 6. 懸念事項と未解決問題

### 6-1. 設計上の懸念

```yaml
懸念1: メタファーの伝わりやすさ
  問題: 「木が育つ = じぶんが育つ」が1年生に伝わるか？
  暫定案: チュートリアルで「この きは きみの まなびの きだよ！」と説明
  Geminiへ: 子どもにとって直感的に理解できるか？

懸念2: 木の形の均一化
  問題: アルゴリズムが同じなら全プレイヤーの木が似た形になる
  暫定案: 枝の角度にランダム要素を加える（seed: プレイヤー名）
  Geminiへ: 個性の出し方として十分か？

懸念3: A案との並立
  問題: A案（家ビルド）と両立すると素材の使い道が複雑になる
  暫定案: Phase 1は家ビルドのみ、Phase 2でB案を追加
  Geminiへ: どちらを優先すべきか？

懸念4: 完了感の欠如
  問題: 「完成がない木」は継続動機になるが達成感が生まれにくい
  暫定案: 単元ごとの達成バッジ、「○本の花が咲いた！」の節目演出
  Geminiへ: 節目の設定の仕方についてアドバイスが欲しい

懸念5: 16単元を超えたとき（Phase 2以降）
  問題: 2年生・3年生のコンテンツ追加時に木はどう成長するか
  暫定案: 学年ごとに新しい木が生える（木が複数本になる）
         または同じ木がどんどん大きくなる
  Geminiへ: 長期的な成長設計のアドバイスが欲しい
```

### 6-2. 技術的な未解決問題

```yaml
未解決1: SVG木のサイズ最適化
  問題: 16単元分の枝・花・実でSVGが複雑になりすぎる恐れ
  検討中: Canvas APIへの切り替え or SVGの動的生成最適化

未解決2: 季節変化のタイミング
  問題: リアルタイムに季節を変えるか、特定イベント時のみか
  検討中: 本棚画面に入るたびにカレンダーチェック

未解決3: 保護者向け機能との連携
  問題: 保護者が子どもの学習記録を見る機能（Phase 1以降）
        木の状態が学習記録として機能するか
  検討中: 「木のスクリーンショット共有」機能
```

---

## 7. Geminiへの質問事項

### 🙋 質問リスト（Geminiレビュー用）

```yaml
Q1 【最重要】A案 vs B案の選択
  質問: 家ビルド（A案）とまなびの き（B案）、
        小学生向け教育ゲームとしてどちらが有効か？
  背景: 開発リソースは限られており、Phase 1では1つに絞りたい

Q2 【重要】折衷案の実現性
  質問: 「家の庭に木を植える」折衷案は有効か？
        UX的に複雑になりすぎないか？

Q3 メタファーの妥当性
  質問: 「学習 = 木の成長」という比喩は、
        日本の小学1年生（6〜7歳）に直感的に伝わるか？
  参考: 類似アプリ・教材での事例があれば教えてほしい

Q4 継続動機の設計
  質問: 「木の飾りシステム」で長期的な継続動機を保てるか？
        他に「木を育て続けたい」と思わせる仕組みはあるか？

Q5 保護者への訴求
  質問: 「まなびの き = 学習の記録」という訴求は保護者に刺さるか？
        「学習記録」機能として設計する際の注意点はあるか？

Q6 季節変化について
  質問: 季節変化（春夏秋冬）は子どものエンゲージメントに効果的か？
        日本の学校カレンダー（4月始まり）に合わせた
        特別演出を入れるべきか？（例: 4月 → 桜の演出）

Q7 【実装優先度】Phase 0でのデータ設計
  質問: Phase 0でtree状態をGameStoreに追加しておくべきか？
        それともPhase 1まで後回しにしていいか？
        （後から追加するとセーブデータ互換性に影響する可能性）
```

---

## 📊 判断フレームワーク

Geminiのレビュー結果を受けて、以下の基準で判断する:

```yaml
判断基準:
  採用条件（B案を採用する場合）:
    - Q1: B案の方が教育効果が高い or 同等以上
    - Q3: 1年生にメタファーが伝わる
    - 実装コストがA案と大差ない

  却下条件（A案を維持する場合）:
    - Q1: A案の方が明らかに優れている
    - Q3: メタファーが難しすぎる
    - 折衷案で対応できる

  折衷案採用条件:
    - Q2: 折衷案が実現可能と判断される
    - Phase 1の実装範囲に収まる

  保留条件（Phase 2以降で再検討）:
    - Q1: 優劣がつかない（トレードオフが拮抗している）
    - Phase 0実装を優先すべき

次のステップ:
  [ ] Geminiレビュー待ち
  [ ] レビュー結果をもとに採用/却下を決定
  [ ] 採用の場合: 統合仕様書v1.4に反映
  [ ] 却下の場合: A案（家ビルド）の詳細仕様を統合仕様書に追記
```

---

## ステータス

**📋 本ドキュメントはGeminiレビュー依頼中**

```yaml
作成日: 2026-02-20
バージョン: 1.0
ステータス: Geminiレビュー依頼中
次のステップ: Geminiレビュー待ち → 採用/却下決定

作成者: Claude
レビュー依頼先: Gemini
人間確認: 要確認
```

---

**Happy Learning & Growing! 🌳✨**
